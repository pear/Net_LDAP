<?php
// Call Net_LDAP_LDIFTest::main() if this source file is executed directly.
if (!defined("PHPUnit_MAIN_METHOD")) {
    define("PHPUnit_MAIN_METHOD", "Net_LDAP_LDIFTest::main");
}

require_once "PHPUnit/Framework/TestCase.php";
require_once "PHPUnit/Framework/TestSuite.php";

require_once 'Net/LDAP/LDIF.php';

/**
 * Test class for Net_LDAP_LDIF.
 * Generated by PHPUnit_Util_Skeleton on 2007-12-20 at 10:11:52.
 */
class Net_LDAP_LDIFTest extends PHPUnit_Framework_TestCase {
    /**
    * Default config for tests.
    *
    * @var array
    */
    var $defaultConfig = array(
        'onerror' => 'undef',
        'encode'  => 'base64',
        'wrap'    => 50,
        'change'  => 0,
        'sort'    => 1,
    );

    /**
    * Test entries data
    *
    * Please do not just modify these values, they
    * are closely related to the LDIF test data.
    *
    * @var string
    */
    var $testentries_data = array(
        'cn=test1,ou=example,dc=cno' => array(
            'cn'    => 'example2',
            'attr3' => array('foo', 'bar'),
            'attr1' => 12345,
            'attr4' => 'brrrzztt',
            'objectclass' => 'oc1',
            'attr2' => array('1234', 'baz')),

        'cn=test blabla,ou=example,dc=cno' => array(
            'cn'    => 'example2',
            'attr3' => array('foo', 'bar'),
            'attr1' => 12345,
            'attr4' => 'blablaצה',
            'objectclass' => 'oc2',
            'attr2' => array('1234', 'baz'),
            'verylong' => 'fhu08rhvt7b478vt5hv78h45nfgt45h78t34hhhhhhhhhv5bg8h6ttttttttt3489t57nhvgh4788trhg8999vnhtgthgui65hgb5789thvngwr789cghm738'),

        'cn=test צה,ou=example,dc=cno' => array(
            'cn'    => 'example2',
            'attr3' => array('foo', 'bar'),
            'attr1' => 12345,
            'attr4' => 'blablaצה',
            'objectclass' => 'oc3',
            'attr2' => array('1234', 'baz'))
    );

    /**
    * Test file written to
    *
    * @var string
    */
    var $outfile = 'test.out.ldif';

    /**
    * Test entries
    *
    * They will be created in main()
    *
    * @var array
    */
    var $testentries = array();

    /**
     * Runs the test methods of this class.
     *
     * @access public
     * @static
     */
    public static function main() {
        require_once "PHPUnit/TextUI/TestRunner.php";

        $suite  = new PHPUnit_Framework_TestSuite("Net_LDAP_LDIFTest");
        $result = PHPUnit_TextUI_TestRunner::run($suite);
    }

    /**
     * Open some outfile and ensure correct rights
     *
     * @access protected
     */
    protected function setUp() {
        // initialize test entries
        $this->testentries = array();
        foreach ($this->testentries_data as $dn => $attrs) {
            $entry = Net_LDAP_Entry::createfresh($dn, $attrs);
            $this->assertType('Net_LDAP_Entry', $entry, 'ERROR inittializing test entries');
            array_push($this->testentries, $entry);
        }

        // create outfile if not exists and enforce proper access rights
        if (!file_exists($this->outfile)) {
            if (!touch($this->outfile)) {
                $this->markTestSkipped('Unable to create '.$this->outfile.', skipping test');
            }
        }
        if (!chmod($this->outfile, 0644)) {
            $this->markTestSkipped('Unable to chmod(0644) '.$this->outfile.', skipping test');
        }
    }

    /**
     * Remove the outfile
     *
     * @access protected
     */
    protected function tearDown() {
        @unlink($this->outfile);
    }

    /**
     * Construction tests
     *
     * Construct LDIF object and see if we can get a handle
     */
    public function testConstruction() {
        $supported_modes = array('r', 'w', 'a');
        $plus            = array('', '+');

        // Test all open modes,
        // all of them should return a correct handle
        foreach ($supported_modes as $mode) {
            foreach ($plus as $p) {
                $ldif = new Net_LDAP_LDIF($this->outfile, $mode, $this->defaultConfig);
                $this->assertTrue(is_resource($ldif->handle()));
            }
        }

        // Test passing custom handle
        $handle = fopen($this->outfile, 'r');
        $ldif = new Net_LDAP_LDIF($handle, $mode, $this->defaultConfig);
        $this->assertTrue(is_resource($ldif->handle()));

        // Reading test with invalid file mode
        $ldif = new Net_LDAP_LDIF($this->outfile, 'y', $this->defaultConfig);
        $this->assertNull($ldif->handle());
        $this->assertType('Net_LDAP_Error', $ldif->error());

        // Reading test with nonexistent file
        $ldif = new Net_LDAP_LDIF('some/nonexistent/file_for_net_ldap_ldif', 'r', $this->defaultConfig);
        $this->assertNull($ldif->handle());
        $this->assertType('Net_LDAP_Error', $ldif->error());

        // writing to nonexistent file
        $ldif = new Net_LDAP_LDIF('testfile_for_net_ldap_ldif', 'w', $this->defaultConfig);
        $this->assertTrue(is_resource($ldif->handle()));
        @unlink('testfile_for_net_ldap_ldif');

        // writing to nonexistent path
        $ldif = new Net_LDAP_LDIF('some/nonexistent/file_for_net_ldap_ldif', 'w', $this->defaultConfig);
        $this->assertNull($ldif->handle());
        $this->assertType('Net_LDAP_Error', $ldif->error());

        // writing to existing file but without permission
        // note: chmod should succeed since we do that in setUp()
        if (chmod($this->outfile, 0444)) {
            $ldif = new Net_LDAP_LDIF($this->outfile, 'w', $this->defaultConfig);
            $this->assertNull($ldif->handle());
            $this->assertType('Net_LDAP_Error', $ldif->error());
        } else {
            $this->markTestIncomplete("Could not chmod ".$this->outfile.", write test without permission skipped");
        }
    }

    /**
     * Tests if entries from an LDIF file are correctly constructed
     */
    public function testRead_entry() {
        $ldif = new Net_LDAP_LDIF(dirname(__FILE__).'/ldif_data/read_testfile.ldif', 'r', $this->defaultConfig);
        $this->assertTrue(is_resource($ldif->handle()));

        $entries = array();
        do {
            $entry = $ldif->read_entry();
            $this->assertFalse((boolean)$ldif->error(), 'failed building entry from LDIF: '.$ldif->error(true));
            $this->assertType('Net_LDAP_Entry', $entry);
            array_push($entries, $entry);
        } while (!$ldif->eof());

        $this->compareEntries($entries, $this->testentries);
    }

    /**
     * @todo Implement testEof().
     */
    public function testEof() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testWrite_entry().
     */
    public function testWrite_entry() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testWrite_version().
     */
    public function testWrite_version() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testVersion().
     */
    public function testVersion() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testHandle().
     */
    public function testHandle() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testDone().
     */
    public function testDone() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testError().
     */
    public function testError() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testError_lines().
     */
    public function testError_lines() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testCurrent_entry().
     */
    public function testCurrent_entry() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testCurrent_lines().
     */
    public function testCurrent_lines() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testNext_lines().
     */
    public function testNext_lines() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_convertAttribute().
     */
    public function test_convertAttribute() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_convertDN().
     */
    public function test_convertDN() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_writeAttribute().
     */
    public function test_writeAttribute() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_writeDN().
     */
    public function test_writeDN() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_finishEntry().
     */
    public function test_finishEntry() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_writeLine().
     */
    public function test_writeLine() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }
    
    
    /**
    * Compare Net_LDAP_Entries
    *
    * This helper function compares two entries (or array of entries)
    * and tells if they are equal. They are equal if all DNs from
    * the first crowd exist in the second AND each attribute is present
    * and equal at the respicitve entry.
    * The search is case sensitive.
    *
    * @param array|Net_LDAP_Entry $entry1
    * @param array|Net_LDAP_Entry $entry2
    * @return true|false
    */
    function compareEntries($entry1, $entry2) {
        if (!is_array($entry1)) $entry1 = array($entry1);
        if (!is_array($entry2)) $entry2 = array($entry2);

        $entries_data1  = array();
        $entries_data2  = array();

        // step 1: extract and sort data
        foreach ($entry1 as $e) {
            $values = $e->getValues();
//             ksort($values);
            foreach ($values as $attr_name => $attr_values) {
                if (!is_array($attr_values)) $attr_values = array($attr_values);
//                 sort($attr_values);
                $values[$attr_name] = $attr_values;
            }
            $entries_data1[$e->dn()] = $values;
        }
        foreach ($entry2 as $e) {
            $values = $e->getValues();
//             ksort($values);
            foreach ($values as $attr_name => $attr_values) {
                if (!is_array($attr_values)) $attr_values = array($attr_values);
//                 sort($attr_values);
                $values[$attr_name] = $attr_values;
            }
            $entries_data2[$e->dn()] = $values;
        }
//         ksort($entries_data1);
//         ksort($entries_data2);

        // step 2: compare DNs (entries)
        $this->assertEquals(array_keys($entries_data1), array_keys($entries_data2), 'Entries DNs not equal! (missing entry or wrong DN)');

        // step 3: look for attribute existence and compare values
        foreach ($entries_data1 as $dn => $attributes) {
            $this->assertEquals($entries_data1[$dn], $entries_data2[$dn], 'Entries '.$dn.' attributes are not equal');
            foreach ($attributes as $attr_name => $attr_values) {
                $this->assertEquals(0, count(array_diff($entries_data1[$dn][$attr_name], $entries_data2[$dn][$attr_name])), 'Entries '.$dn.' attribute '.$attr_name.' values are not equal');
            }
        }

        return true;
    }

}

// Call Net_LDAP_LDIFTest::main() if this source file is executed directly.
if (PHPUnit_MAIN_METHOD == "Net_LDAP_LDIFTest::main") {
    Net_LDAP_LDIFTest::main();
}
?>