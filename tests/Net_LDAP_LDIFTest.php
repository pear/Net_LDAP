<?php
// Call Net_LDAP_LDIFTest::main() if this source file is executed directly.
if (!defined("PHPUnit_MAIN_METHOD")) {
    define("PHPUnit_MAIN_METHOD", "Net_LDAP_LDIFTest::main");
}

require_once "PHPUnit/Framework/TestCase.php";
require_once "PHPUnit/Framework/TestSuite.php";

require_once 'Net/LDAP/LDIF.php';

/**
 * Test class for Net_LDAP_LDIF.
 * Generated by PHPUnit_Util_Skeleton on 2007-12-20 at 10:11:52.
 */
class Net_LDAP_LDIFTest extends PHPUnit_Framework_TestCase {
    /**
    * Default config for tests.
    *
    * The config is bound to the ldif test file
    * tests/ldif_data/unsorted_w50.ldif
    * so don't change or tests will fail
    *
    * @var array
    */
    var $defaultConfig = array(
        'onerror' => 'undef',
        'encode'  => 'base64',
        'wrap'    => 50,
        'change'  => 0,
        'sort'    => 0,
    );

    /**
    * Test entries data
    *
    * Please do not just modify these values, they
    * are closely related to the LDIF test data.
    *
    * @var string
    */
    var $testentries_data = array(
        'cn=test1,ou=example,dc=cno' => array(
            'cn'    => 'test1',
            'attr3' => array('foo', 'bar'),
            'attr1' => 12345,
            'attr4' => 'brrrzztt',
            'objectclass' => 'oc1',
            'attr2' => array('1234', 'baz')),

        'cn=test blabla,ou=example,dc=cno' => array(
            'cn'    => 'test blabla',
            'attr3' => array('foo', 'bar'),
            'attr1' => 12345,
            'attr4' => 'blablaצה',
            'objectclass' => 'oc2',
            'attr2' => array('1234', 'baz'),
            'verylong' => 'fhu08rhvt7b478vt5hv78h45nfgt45h78t34hhhhhhhhhv5bg8h6ttttttttt3489t57nhvgh4788trhg8999vnhtgthgui65hgb5789thvngwr789cghm738'),

        'cn=test צה,ou=example,dc=cno' => array(
            'cn'    => 'test צה',
            'attr3' => array('foo', 'bar'),
            'attr1' => 12345,
            'attr4' => 'blablaצה',
            'objectclass' => 'oc3',
            'attr2' => array('1234', 'baz'))
    );

    /**
    * Test file written to
    *
    * @var string
    */
    var $outfile = 'test.out.ldif';

    /**
    * Test entries
    *
    * They will be created in main()
    *
    * @var array
    */
    var $testentries = array();

    /**
     * Runs the test methods of this class.
     *
     * @access public
     * @static
     */
    public static function main() {
        require_once "PHPUnit/TextUI/TestRunner.php";

        $suite  = new PHPUnit_Framework_TestSuite("Net_LDAP_LDIFTest");
        $result = PHPUnit_TextUI_TestRunner::run($suite);
    }

    /**
     * Open some outfile and ensure correct rights
     *
     * @access protected
     */
    protected function setUp() {
        // initialize test entries
        $this->testentries = array();
        foreach ($this->testentries_data as $dn => $attrs) {
            $entry = Net_LDAP_Entry::createfresh($dn, $attrs);
            $this->assertType('Net_LDAP_Entry', $entry, 'ERROR inittializing test entries');
            array_push($this->testentries, $entry);
        }

        // create outfile if not exists and enforce proper access rights
        if (!file_exists($this->outfile)) {
            if (!touch($this->outfile)) {
                $this->markTestSkipped('Unable to create '.$this->outfile.', skipping test');
            }
        }
        if (!chmod($this->outfile, 0644)) {
            $this->markTestSkipped('Unable to chmod(0644) '.$this->outfile.', skipping test');
        }
    }

    /**
     * Remove the outfile
     *
     * @access protected
     */
    protected function tearDown() {
        @unlink($this->outfile);
    }

    /**
     * Construction tests
     *
     * Construct LDIF object and see if we can get a handle
     */
    public function testConstruction() {
        $supported_modes = array('r', 'w', 'a');
        $plus            = array('', '+');

        // Test all open modes,
        // all of them should return a correct handle
        foreach ($supported_modes as $mode) {
            foreach ($plus as $p) {
                $ldif = new Net_LDAP_LDIF($this->outfile, $mode, $this->defaultConfig);
                $this->assertTrue(is_resource($ldif->handle()));
            }
        }

        // Test passing custom handle
        $handle = fopen($this->outfile, 'r');
        $ldif = new Net_LDAP_LDIF($handle, $mode, $this->defaultConfig);
        $this->assertTrue(is_resource($ldif->handle()));

        // Reading test with invalid file mode
        $ldif = new Net_LDAP_LDIF($this->outfile, 'y', $this->defaultConfig);
        $this->assertNull($ldif->handle());
        $this->assertType('Net_LDAP_Error', $ldif->error());

        // Reading test with nonexistent file
        $ldif = new Net_LDAP_LDIF('some/nonexistent/file_for_net_ldap_ldif', 'r', $this->defaultConfig);
        $this->assertNull($ldif->handle());
        $this->assertType('Net_LDAP_Error', $ldif->error());

        // writing to nonexistent file
        $ldif = new Net_LDAP_LDIF('testfile_for_net_ldap_ldif', 'w', $this->defaultConfig);
        $this->assertTrue(is_resource($ldif->handle()));
        @unlink('testfile_for_net_ldap_ldif');

        // writing to nonexistent path
        $ldif = new Net_LDAP_LDIF('some/nonexistent/file_for_net_ldap_ldif', 'w', $this->defaultConfig);
        $this->assertNull($ldif->handle());
        $this->assertType('Net_LDAP_Error', $ldif->error());

        // writing to existing file but without permission
        // note: chmod should succeed since we do that in setUp()
        if (chmod($this->outfile, 0444)) {
            $ldif = new Net_LDAP_LDIF($this->outfile, 'w', $this->defaultConfig);
            $this->assertNull($ldif->handle());
            $this->assertType('Net_LDAP_Error', $ldif->error());
        } else {
            $this->markTestIncomplete("Could not chmod ".$this->outfile.", write test without permission skipped");
        }
    }

    /**
     * Tests if entries from an LDIF file are correctly constructed
     */
    public function testRead_entry() {
        $ldif = new Net_LDAP_LDIF(dirname(__FILE__).'/ldif_data/unsorted_w50.ldif', 'r', $this->defaultConfig);
        $this->assertTrue(is_resource($ldif->handle()));

        $entries = array();
        do {
            $entry = $ldif->read_entry();
            $this->assertFalse((boolean)$ldif->error(), 'failed building entry from LDIF: '.$ldif->error(true));
            $this->assertType('Net_LDAP_Entry', $entry);
            array_push($entries, $entry);
        } while (!$ldif->eof());

        $this->compareEntries($entries, $this->testentries);
    }

    /**
     * Tests if entries are correctly written
     */
    public function testWrite_entry() {
        $expected = file(dirname(__FILE__).'/ldif_data/unsorted_w50.ldif');
        // strip 4 starting lines because of comments in the file header:
        array_shift($expected);array_shift($expected);
        array_shift($expected);array_shift($expected);

        // Write LDIF
        $ldif = new Net_LDAP_LDIF($this->outfile, 'w', $this->defaultConfig);
        $this->assertTrue(is_resource($ldif->handle()));
        $ldif->write_entry($this->testentries);
        $this->assertFalse((boolean)$ldif->error(), 'Failed writing entry to '.$this->outfile.': '.$ldif->error(true));
        $ldif->done();

        // Compare files
        $this->assertEquals($expected, file($this->outfile));
    }

    /**
     * Round trip test: Read LDIF, parse to entries, write that to LDIF and compare both files
     */
    public function testReadWriteRead() {
        $ldif = new Net_LDAP_LDIF(dirname(__FILE__).'/ldif_data/unsorted_w50.ldif', 'r', $this->defaultConfig);
        $this->assertTrue(is_resource($ldif->handle()));

        // Read LDIF
        $entries = array();
        do {
            $entry = $ldif->read_entry();
            $this->assertFalse((boolean)$ldif->error(), 'failed building entry from LDIF: '.$ldif->error(true));
            $this->assertType('Net_LDAP_Entry', $entry);
            array_push($entries, $entry);
        } while (!$ldif->eof());
        $ldif->done();

         // Write LDIF
         $ldif = new Net_LDAP_LDIF($this->outfile, 'w', $this->defaultConfig);
         $this->assertTrue(is_resource($ldif->handle()));
         $ldif->write_entry($entries);
         $this->assertFalse((boolean)$ldif->error(), 'Failed writing entry to '.$this->outfile.': '.$ldif->error(true));
         $ldif->done();

         // Compare files
         $expected = file(dirname(__FILE__).'/ldif_data/unsorted_w50.ldif');
         // strip 4 starting lines because of comments in the file header:
         array_shift($expected);array_shift($expected);
         array_shift($expected);array_shift($expected);
         $this->assertEquals($expected, file($this->outfile));
    }

    /**
    * Tests if values are converted (encoding, wrapping etc) correctly
    */
    public function testAttributeConversion() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );

        // TODO: Test encoding

        // TODO: Test wrapping
    }

    /**
    * Tests if DNs are converted  correctly
    */
    public function testDNConversion() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
    * Tests if syntax errors are detected
    */
    public function testSyntaxerrors() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
        // Test malformed encoding

        // Test malformed syntax

        // test bad wrapping
    }

    /**
     * Test error dropping functionality
     */
    public function testError() {
        // NO error:
        $ldif = new Net_LDAP_LDIF(dirname(__FILE__).'/ldif_data/unsorted_w50.ldif', 'r', $this->defaultConfig);
        $this->assertFalse((boolean)$ldif->error());

        // Error giving error msg and line number:
        $ldif = new Net_LDAP_LDIF(dirname(__FILE__).'/ldif_data/unsorted_w50.ldif', 'r', $this->defaultConfig);
        $this->assertTrue((boolean)$ldif->error());
        $this->assertType('string', $ldif->error());
        $this->assertType('int', $ldif->error_line());
        $this->assertThis(strlen($ldif->error()), $this->greaterThan(0));
    }

    /**
     * @todo Implement testError_lines().
     */
    public function testError_lines() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testCurrent_entry().
     */
    public function testCurrent_entry() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testCurrent_lines().
     */
    public function testCurrent_lines() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement testNext_lines().
     */
    public function testNext_lines() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_convertAttribute().
     */
    public function test_convertAttribute() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_convertDN().
     */
    public function test_convertDN() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_writeAttribute().
     */
    public function test_writeAttribute() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_writeDN().
     */
    public function test_writeDN() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_finishEntry().
     */
    public function test_finishEntry() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }

    /**
     * @todo Implement test_writeLine().
     */
    public function test_writeLine() {
        // Remove the following line when you implement this test.
        $this->markTestIncomplete(
          "This test has not been implemented yet."
        );
    }
    
    
    /**
    * Compare Net_LDAP_Entries
    *
    * This helper function compares two entries (or array of entries)
    * and tells if they are equal. They are equal if all DNs from
    * the first crowd exist in the second AND each attribute is present
    * and equal at the respicitve entry.
    * The search is case sensitive.
    *
    * @param array|Net_LDAP_Entry $entry1
    * @param array|Net_LDAP_Entry $entry2
    * @return true|false
    */
    function compareEntries($entry1, $entry2) {
        if (!is_array($entry1)) $entry1 = array($entry1);
        if (!is_array($entry2)) $entry2 = array($entry2);

        $entries_data1  = array();
        $entries_data2  = array();

        // step 1: extract and sort data
        foreach ($entry1 as $e) {
            $values = $e->getValues();
            foreach ($values as $attr_name => $attr_values) {
                if (!is_array($attr_values)) $attr_values = array($attr_values);
                $values[$attr_name] = $attr_values;
            }
            $entries_data1[$e->dn()] = $values;
        }
        foreach ($entry2 as $e) {
            $values = $e->getValues();
            foreach ($values as $attr_name => $attr_values) {
                if (!is_array($attr_values)) $attr_values = array($attr_values);
                $values[$attr_name] = $attr_values;
            }
            $entries_data2[$e->dn()] = $values;
        }

        // step 2: compare DNs (entries)
        $this->assertEquals(array_keys($entries_data1), array_keys($entries_data2), 'Entries DNs not equal! (missing entry or wrong DN)');

        // step 3: look for attribute existence and compare values
        foreach ($entries_data1 as $dn => $attributes) {
            $this->assertEquals($entries_data1[$dn], $entries_data2[$dn], 'Entries '.$dn.' attributes are not equal');
            foreach ($attributes as $attr_name => $attr_values) {
                $this->assertEquals(0, count(array_diff($entries_data1[$dn][$attr_name], $entries_data2[$dn][$attr_name])), 'Entries '.$dn.' attribute '.$attr_name.' values are not equal');
            }
        }

        return true;
    }

}

// Call Net_LDAP_LDIFTest::main() if this source file is executed directly.
if (PHPUnit_MAIN_METHOD == "Net_LDAP_LDIFTest::main") {
    Net_LDAP_LDIFTest::main();
}
?>